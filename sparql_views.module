<?php
// $Id$
function sparql_views_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'sparql_views'),
  );
  return '3.0-alpha1';
}

function _sparql_views_get_namespaces() {
  $rdf_namespaces = &drupal_static(__FUNCTION__);
  if (empty($rdf_namespaces)) {
    $rdf_namespaces = module_invoke_all('rdf_namespaces');
    foreach($rdf_namespaces as $ns => $url) {
      if(is_array($url)) {
        $rdf_namespaces[$ns] = $url[0];
      }
    }
  }
  // @todo ensure there are no duplicates and that array is only one level.
  return $rdf_namespaces;
}

/*
 * Implements hook_permission().
 */
function sparql_views_permission() {
  return array(
    'administer sparql_views types' => array(
      'title' => t('Administer SPARQL Views entities'), 
      'description' => t('Add new entities and manage fields to be used in SPARQL Views queries.'),
    ),
  );
}

function sparql_views_rdf_namespaces() {
  return array(
    'dbpedia2' => 'http://dbpedia.org/property/',
  );
}

function sparql_views_entity_access($op, $node = NULL, $account = NULL) {
  if (user_access('administer sparql_views types', $account)) {
    return TRUE;
  }
  return FALSE;
}

/*
 * Implements hook_module_implements_alter().
 *
 * This is necessary because Entity API recommends attaching bundles to
 * entity info in hook_entity_info_alter(). However, rdf also attaches its
 * mappings to the bundle with rdf_entity_info_alter. If the hook implementation
 * for the entity comes after RDF, the mappings will not be attached.
 */
function sparql_views_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_info_alter') {
    $temp = $implementations['rdf'];
    unset($implementations['rdf']);
    $implementations['rdf'] = $temp;
  }  
}

/**
 * Implement hook_entity_info().
 */
function sparql_views_entity_info() {
  $return = array(
    'sparql_views' => array(
      'label' => t('Test Entity'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'base table' => 'sparql_views_entity',
      'fieldable' => TRUE,
      'access callback' => 'sparql_views_entity_access',
      'admin ui' => array(
        'path' => 'admin/structure/sparql_views/types',
      ),
      'entity keys' => array(
        'id' => 'type',
        'bundle' => 'name',
      ),
      // Make use the class' label() and uri() implementation by default.
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'bundles' => array(
        'dbpedia_example'=> array(
          'label' => 'PostIt',
          'admin' => array(
            'path' => 'admin/structure/sparql_views/types/manage/dbpedia_example',
            'access arguments' => array('administer dbpedia_examples'),
          ),
        ),
      ),
      'bundle keys' => array(
        'bundle' => 'name',
      ),
    ),
  );
  return $return;
}

/**
 * Implement hook_entity_info_alter().
 *
 * Use this hook to specify entity test bundles to avoid a recursion, as loading
 * the entity test types needs the entity info too.
 */
function sparql_views_entity_info_alter(&$entity_info) {
  foreach (sparql_views_get_types() as $info) {
    $entity_info['sparql_views']['bundles'][$info->name] = array(
      'label' => $info->name,
      'admin' => array(
        'path' => "admin/structure/sparql_views/types/manage/$info->name",
        'bundle argument' => 5,
        'access arguments' => array('administer sparql_views types'),
      ),
    );
  }
}

/**
 * Gets an array of all test entity types, keyed by the name.
 *
 * @param $name
 *   If set, the type with the given name is returned.
 */
function sparql_views_get_types($name = NULL) {
  $types = entity_load('sparql_views', isset($name) ? array($name) : FALSE);
  if (isset($name)) {
    return isset($types[$name]) ? $types[$name] : FALSE;
  }
  return $types;
}

/**
 * Displays the SPARQL Views type admin overview page.
 */
function sparql_views_overview_form() {
  $entity_info = entity_get_info('sparql_views');
  $types = $entity_info['bundles'];
  $names = array();
  $field_ui = module_exists('field_ui');
  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => $field_ui ? '4' : '2'));
  $rows = array();

  foreach ($types as $key => $type) {
    $description = isset($type['description']) ? $type['description'] : '';
    $type_definition = array('type' => $key, 'description' => $description);
    $row = array(theme('node_admin_overview', array('name' => $type['label'], 'type' => (object) $type_definition)));
    // Set the edit column.
    $row[] = array('data' => l(t('edit'), 'admin/structure/sparql_views/types/manage/' . $key));

    if ($field_ui) {
      // Manage fields.
      $row[] = array('data' => l(t('manage fields'), 'admin/structure/sparql_views/types/manage/' . $key . '/fields'));

      // Display fields.
      $row[] = array('data' => l(t('manage display'), 'admin/structure/sparql_views/types/manage/' . $key . '/display'));
    }
    if (isset($type['custom'])) {
      $row[] = array('data' => l(t('delete'), 'admin/structure/sparql_views/types/manage/' . $key . '/delete'));
    }
    $rows[] = $row;
  }

  $build['node_table'] = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#empty' => t('No content types available. <a href="@link">Add content type</a>.', array('@link' => url('admin/structure/types/add'))),
  );

  return $build;
}

/**
 * Generates the node type editing form.
 */
function sparql_views_form($form, &$form_state, $sparql_views, $op = 'edit') {
  if ($op == 'clone') {
    $sparql_views->label .= ' (cloned)';
    $sparql_views->type .= '_clone';
  }
  else if ($op == 'add') {
    sparql_views_type_set_defaults();
    $sparql_views->label = '';
  }

  $form['label'] = array(
    '#title' => t('Label'),
    '#type' => 'textfield',
    '#default_value' => $sparql_views->label,
  );
  // Machine-readable type name.
  $form['type'] = array(
    '#type' => 'machine_name',
    '#default_value' => isset($sparql_views->type) ? $sparql_views->type : '',
    //'#disabled' => $sparql_views->isLocked(),
    '#machine_name' => array(
      'exists' => 'sparql_views_get_types',
      'source' => array('label'),
    ),
    '#description' => t('A unique machine-readable name for this profile type. It must only contain lowercase letters, numbers, and underscores.'),
  );
  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save profile type'),
    '#weight' => 40,
  );
  return $form;
}

/**
 * Form API submit callback for the type form.
 */
function sparql_views_form_submit(&$form, &$form_state) {
  $sparql_views = entity_ui_form_submit_build_entity($form, $form_state);
  // Save and go back.
  $sparql_views->name = $sparql_views->type;
  $sparql_views->save();
//  $form_state['redirect'] = 'admin/structure/sparql_views/types';
}

/**
 * Sets the default values for a node type.
 *
 * The defaults are appropriate for a type defined through hook_node_info(),
 * since 'custom' is TRUE for types defined in the user interface, and FALSE
 * for types defined by modules. (The 'custom' flag prevents types from being
 * deleted through the user interface.) Also, the default for 'locked' is TRUE,
 * which prevents users from changing the machine name of the type.
 *
 * @param $info
 *   An object or array containing values to override the defaults. See
 *   hook_node_info() for details on what the array elements mean.
 *
 * @return
 *   A node type object, with missing values in $info set to their defaults.
 */
function sparql_views_type_set_defaults($info = array()) {
  $info = (array) $info;
  $new_type = $info + array(
    'type' => '',
    'name' => '',
    'base' => '',
    'description' => '',
    'help' => '',
    'custom' => 0,
    'modified' => 0,
    'locked' => 1,
    'disabled' => 0,
    'is_new' => 1,
    'has_title' => 0,
    'title_label' => 'Title',
  );
  $new_type = (object) $new_type;

  // If the type has no title, set an empty label.
  if (!$new_type->has_title) {
    $new_type->title_label = '';
  }
  if (empty($new_type->module)) {
    $new_type->module = $new_type->base == 'node_content' ? 'node' : '';
  }
  $new_type->orig_type = isset($info['type']) ? $info['type'] : '';

  return $new_type;
}

/*function sparql_views_type_get_types($rebuild = FALSE) {
  if (!$rebuild) {
    $sparql_views_types = &drupal_static(__FUNCTION__);
    if (isset($sparql_views_types)) {
      return $sparql_views_types;
    }
  }
  $query = db_select('sparql_views_entity', 'sve')
    ->fields('name')
    ->orderBy('sve.name', 'ASC');
  $types = $query->execute()->fetchAll();
  dpm($types);
  return 'dbpedia_example';
}*/

/**
 * Delete multiple test entities.
 *
 * @param $pids
 *   An array of test entity IDs.
 */
function sparql_views_delete_multiple(array $pids) {
  entity_get_controller('sparql_views')->delete($pids);
}

function _sparql_views_predicate_ns($predicate) {
  $split = explode(':', $predicate);
  if(count($split) == 2)
    return $split[0];
  return FALSE; 
}