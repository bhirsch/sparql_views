<?php
// $Id$
function sparql_views_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'sparql_views'),
  );
  return '3.0-alpha1';
}

/*
 * Implements hook_permission().
 */
function sparql_views_permission() {
  return array(
    'administer sparql_views types' => array(
      'title' => t('Administer SPARQL Views entities'), 
      'description' => t('Add new entities and manage fields to be used in SPARQL Views queries.'),
    ),
  );
}

function sparql_views_rdf_namespaces() {
  return array(
    'dbpedia2' => 'http://dbpedia.org/property/',
  );
}

function sparql_views_entity_access($op, $node = NULL, $account = NULL) {
  if (user_access('administer sparql_views types', $account)) {
    return TRUE;
  }
  return FALSE;
}

/*
 * Implements hook_module_implements_alter().
 *
 * This is necessary because Entity API recommends attaching bundles to
 * entity info in hook_entity_info_alter(). However, rdf also attaches its
 * mappings to the bundle with rdf_entity_info_alter. If the hook implementation
 * for the entity comes after RDF, the mappings will not be attached.
 */
function sparql_views_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_info_alter') {
    $temp = $implementations['rdf'];
    unset($implementations['rdf']);
    $implementations['rdf'] = $temp;
  }  
}

/**
 * Implement hook_entity_info().
 */
function sparql_views_entity_info() {
  $return = array(
    'sparql_views_entity' => array(
      'label' => t('SPARQL Views Entity'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'base table' => 'sparql_views_entity',
      'fieldable' => TRUE,
      'access callback' => 'sparql_views_entity_access',
      'admin ui' => array(
        'path' => 'admin/structure/sparql_views/types',
      ),
      'entity keys' => array(
        'id' => 'type',
        'bundle' => 'name',
      ),
      // Make use the class' label() and uri() implementation by default.
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'bundles' => array(
        'dbpedia_example'=> array(
          'label' => 'PostIt',
          'admin' => array(
            'path' => 'admin/structure/sparql_views/types/manage/dbpedia_example',
            'access arguments' => array('administer dbpedia_examples'),
          ),
        ),
      ),
      'bundle keys' => array(
        'bundle' => 'name',
      ),
    ),
  );
  return $return;
}

/**
 * Implement hook_entity_info_alter().
 *
 * Use this hook to specify entity test bundles to avoid a recursion, as loading
 * the entity test types needs the entity info too.
 */
function sparql_views_entity_info_alter(&$entity_info) {
  foreach (sparql_views_get_types() as $info) {
    $entity_info['sparql_views_entity']['bundles'][$info->name] = array(
      'label' => $info->name,
      'admin' => array(
        'path' => "admin/structure/sparql_views/types/manage/$info->name",
        'bundle argument' => 5,
        'access arguments' => array('administer sparql_views types'),
      ),
    );
  }
}

/**
 * Gets an array of all test entity types, keyed by the name.
 *
 * @param $name
 *   If set, the type with the given name is returned.
 */
function sparql_views_get_types($name = NULL) {
  $types = entity_load('sparql_views_entity', isset($name) ? array($name) : FALSE);
  if (isset($name)) {
    return isset($types[$name]) ? $types[$name] : FALSE;
  }
  return $types;
}

/**
 * Displays the SPARQL Views type admin overview page.
 */
function sparql_views_entity_overview_form() {
  $entity_info = entity_get_info('sparql_views_entity');
  $types = $entity_info['bundles'];
  $names = array();
  $field_ui = module_exists('field_ui');
  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => $field_ui ? '4' : '2'));
  $rows = array();

  foreach ($types as $key => $type) {
    $description = isset($type['description']) ? $type['description'] : '';
    $type_definition = array('type' => $key, 'description' => $description);
    $row = array(theme('node_admin_overview', array('name' => $type['label'], 'type' => (object) $type_definition)));
    // Set the edit column.
    $row[] = array('data' => l(t('edit'), 'admin/structure/sparql_views/types/manage/' . $key));

    if ($field_ui) {
      // Manage fields.
      $row[] = array('data' => l(t('manage fields'), 'admin/structure/sparql_views/types/manage/' . $key . '/fields'));

      // Display fields.
      $row[] = array('data' => l(t('manage display'), 'admin/structure/sparql_views/types/manage/' . $key . '/display'));
    }
    if (isset($type['custom'])) {
      $row[] = array('data' => l(t('delete'), 'admin/structure/sparql_views/types/manage/' . $key . '/delete'));
    }
    $rows[] = $row;
  }

  $build['node_table'] = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#empty' => t('No content types available. <a href="@link">Add content type</a>.', array('@link' => url('admin/structure/types/add'))),
  );

  return $build;
}

/**
 * Generates the node type editing form.
 */
function sparql_views_entity_form($form, &$form_state, $sparql_views, $op = 'edit') {
  if ($op == 'clone') {
    $sparql_views->label .= ' (cloned)';
    $sparql_views->type .= '_clone';
  }
  else if ($op == 'add') {
    $sparql_views->label = '';
  }

  $form['label'] = array(
    '#title' => t('Label'),
    '#type' => 'textfield',
    '#default_value' => $sparql_views->label,
  );
  // Machine-readable type name.
  $form['type'] = array(
    '#type' => 'machine_name',
    '#default_value' => isset($sparql_views->type) ? $sparql_views->type : '',
    '#machine_name' => array(
      'exists' => 'sparql_views_get_types',
      'source' => array('label'),
    ),
    '#description' => t('A unique machine-readable name for this profile type. It must only contain lowercase letters, numbers, and underscores.'),
  );
  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save profile type'),
    '#weight' => 40,
  );
  return $form;
}

/**
 * Form API submit callback for the type form.
 */
function sparql_views_entity_form_submit(&$form, &$form_state) {
  $sparql_views = entity_ui_form_submit_build_entity($form, $form_state);
  // Save and go back.
  $sparql_views->name = $sparql_views->type;
  $sparql_views->save();
//  $form_state['redirect'] = 'admin/structure/sparql_views/types';
}

/**
 * Delete multiple test entities.
 *
 * @param $pids
 *   An array of test entity IDs.
 */
function sparql_views_delete_multiple(array $pids) {
  entity_get_controller('sparql_views_entity')->delete($pids);
}

function _sparql_views_predicate_ns($predicate) {
  $split = explode(':', $predicate);
  if(count($split) == 2)
    return $split[0];
  return FALSE; 
}